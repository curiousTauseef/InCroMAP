/**
 * @author Clemens Wrzodek
 */
package de.zbit.visualization;

import java.awt.Color;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import y.base.Edge;
import y.base.Node;
import y.base.NodeMap;
import y.layout.organic.SmartOrganicLayouter;
import y.view.Graph2D;
import y.view.Graph2DLayoutExecutor;
import y.view.NodeLabel;
import y.view.NodeRealizer;
import y.view.Selections;
import y.view.ShapeNodeRealizer;
import de.zbit.data.NameAndSignals;
import de.zbit.data.Signal.MergeType;
import de.zbit.data.miRNA.miRNA;
import de.zbit.data.miRNA.miRNAtarget;
import de.zbit.gui.IntegratorUI;
import de.zbit.kegg.TranslatorTools;
import de.zbit.kegg.io.KEGG2yGraph;
import de.zbit.util.StringUtil;

/**
 * A special class to visualize lists of {@link miRNA}s in {@link Graph2D}s.
 * @author Clemens Wrzodek
 */
public class VisualizeMicroRNAdata {
  public static final transient Logger log = Logger.getLogger(VisualizeMicroRNAdata.class.getName());
  
  /**
   * Interaction type for edges from miRNA nodes to mRNA(/Gene) nodes.
   */
  private static final String MIRNA_MRNA_INTERACTION_TYPE = "binding/association";
  
  /**
   * This is the graph on which all operations are performed.
   */
  Graph2D graph;
  
  /**
   * Tools used in various methods.
   */
  TranslatorTools tools;
  
  public VisualizeMicroRNAdata(Graph2D graph) {
    super();
    this.graph = graph;
    this.tools  = new TranslatorTools(graph);
  }


  /**
   * Adds microRNAs and target relationships to graph.
   * @param data
   * @return number of created (or already existing) microRNA nodes in the {@link #graph},
   * corresponding to the <code>data</code>.
   */
  public int addMicroRNAsToGraph(Collection<? extends miRNA> data) {
    // MergeType does NOT make any difference, because input data has NO SIGNALS!
    data = NameAndSignals.geneCentered(data, MergeType.Mean);
    
    Map<Integer, List<Node>> gi2n_map = tools.getGeneID2NodeMap();
    Map<String, Node> mi2n_map = tools.getRNA2NodeMap();
    Set<Node> nodesToLayout = new HashSet<Node>();
    
    int visualizedMiRNAs = 0;
    for (miRNA m : data) {
      if (!m.hasTargets()) continue;
      for (miRNAtarget t: m.getUniqueTargets()) { // Merges duplicate target gene ids
        List<Node> targetNodes = gi2n_map.get(t.getTarget());
        if (targetNodes!=null && targetNodes.size()>0) {
          visualizedMiRNAs++;
          
          // we have a microRNA that has targets that are contained in the current graph.
          Node mi_node = getMicroRNAnode(mi2n_map, m);
          nodesToLayout.add(mi_node);
          
          // Create edges from miRNA node to all targets.
          for (Node target: targetNodes) {
            if (!graph.containsEdge(mi_node, target)) {
              Edge e = graph.createEdge(mi_node, target);
              graph.getRealizer(e).setLineColor(Color.GRAY);
              tools.setInfo(e, "description", t.getSource());
              tools.setInfo(e, "interactionType", MIRNA_MRNA_INTERACTION_TYPE);
            }
          }
        }
      }
      
    }
    
    // Layout new added nodes.
    layoutNodeSubset(nodesToLayout);
    
    return visualizedMiRNAs;
  }
  
  /**
   * Returns or creates and returns a node, for the given microRNA.
   * @param mi2n_map up-to-date map from microRNA name to actual node. May be generated by {@link #getRNA2NodeMap()}.
   * @param mirna microRNA to retrieve (or create if not exists) the node for.
   * @return {@link Node} for the miRNA.
   */
  private Node getMicroRNAnode(Map<String, Node> mi2n_map, miRNA mirna) {
    String nameInMap = mirna.getName().toUpperCase().trim();
    Node n = mi2n_map.get(nameInMap);
    
    if (n==null) {
      n = createMicroRNANode(mirna);
      mi2n_map.put(nameInMap, n);
    }
    
    return n;
  }



  /**
   * @param mirna
   * @return
   */
  private Node createMicroRNANode(miRNA mirna) {
    String label = mirna.getName();
    // Trim organism prefix from microRNA.
    int pos = label.indexOf("miR");
    if (pos>=0) {
      label = label.substring(pos);
    } else if (StringUtil.countChar(label, '-')==2) {
      label = label.substring(label.indexOf('-')+1);
    }
    
    NodeRealizer nr = new ShapeNodeRealizer(ShapeNodeRealizer.TRIANGLE);
    nr.setFillColor(IntegratorUI.LIGHT_BLUE);
    
    NodeLabel nl = new NodeLabel(label);//nr.createNodeLabel(); nl.setText(label);
    nl.setFontSize(10);
    nl.setTextColor(Color.BLACK);
    nr.setLabel(nl);
    
    // Store hyperlinks in the node-label (and later on in the node itself).
    String link = String.format("http://www.mirbase.org/cgi-bin/mirna_entry.pl?id=%s", mirna.getName().trim());
    if (link!=null && link.length()!=0) {
      try {
        // Convert to URL, because type is infered of the submitted object
        // and URL is better than STRING.
        nl.setUserData(new URL(link));
      } catch (MalformedURLException e1) {
        nl.setUserData(link);
      }
    }
    
    nr.setWidth(15);
    nr.setHeight(15);
    
    Node n = graph.createNode(nr);
    tools.setInfo(n, "nodeLabel", mirna.getName());
    tools.setInfo(n, "type", TranslatorTools.RNA_TYPE);
    tools.setInfo(n, "url", link);
    tools.setInfo(n, "nodeColor", KEGG2yGraph.ColorToHTML(nr.getFillColor()) );
    tools.setInfo(n, "nodeName", nl.getText());
    
    return n;
  }
  
  /**
   * Layout the freshly added nodes.
   * @param newNodes nodes to layout
   */
  private void layoutNodeSubset(Set<Node> newNodes) {
    if (newNodes==null || newNodes.size()<1) return;
    
    // Create a selection map that contains all new nodes.
    NodeMap dp = Selections.createSelectionNodeMap(graph);
    for (Node n : graph.getNodeArray()) {
      dp.setBool(n, newNodes.contains(n));
    }
    graph.addDataProvider(SmartOrganicLayouter.NODE_SUBSET_DATA, dp);
    
    // Create layouter and perform layout
    SmartOrganicLayouter layouter = new SmartOrganicLayouter();
    layouter.setScope(SmartOrganicLayouter.SCOPE_SUBSET);
    // If SmartComponentLayoutEnabled is true, all new nodes will
    // simply be put one above the other. If false, they are lyouted
    // nicely, BUT orphans are being moved, too :-(
//    layouter.setSmartComponentLayoutEnabled(true);
    layouter.setNodeOverlapsAllowed(newNodes.size()>30);
    layouter.setConsiderNodeLabelsEnabled(true);
    
//    OrganicLayouter layouter = new OrganicLayouter();
//    layouter.setSphereOfAction(OrganicLayouter.ONLY_SELECTION);
    
    Graph2DLayoutExecutor l = new Graph2DLayoutExecutor();
    l.doLayout(graph, layouter);
    
    // Write initial position to node annotations
    for (Node n:newNodes) {
      NodeRealizer nr = graph.getRealizer(n);
      tools.setInfo(n, "nodePosition", (int) nr.getX() + "|" + (int) nr.getY());
    }
    
    // remove selection map after layouting.
    graph.removeDataProvider(SmartOrganicLayouter.NODE_SUBSET_DATA);
    
    // Reset layout, because subset scope doesn't work correctly.
    new TranslatorTools(graph).resetLayout();
  }


}
